from typing import Optional

import pandas as pd

from psrg_welcome.zips import local_zip_codes


def filter_local_hams(new_hams: pd.DataFrame) -> pd.DataFrame:
    """
    Return the subset of hams that are within 30km of Seattle downtown.

    Parameters
    ----------
    new_hams : pd.DataFrame
        A dataframe containing new ham callsigns and email addresses.

    Returns
    -------
    pd.DataFrame
        The same dataframe, with only hams with a local zip code.
    """

    return new_hams.loc[new_hams["Zip"].str[:5].isin(local_zip_codes)]


def extract_from_csv(
    new_arrl_csv: str, previously_emailed_csv: Optional[str] = None
) -> pd.DataFrame:
    """
    Pull callsigns and any listed emails from the monthly new ham CSV.

    Parameters
    ----------
    new_arrl_csv : str
        The filename for the .csv file containing new ham details.
    
    Returns
    -------
    pd.DataFrame
        A dataframe containing new ham information.
    """

    # Read the file without a header; it's not always formatted correctly
    new_hams = pd.read_csv(new_arrl_csv, header=None).rename(
        columns={0: "Callsign", 1: "Name", 9: "Zip", 12: "Class", 14: "Email"}
    )[["Callsign", "Name", "Class", "Email", "Zip"]]

    # Throw out any header that's partway through the file
    new_hams = new_hams.loc[new_hams["Callsign"].str.len() < 7]

    # Keep only local hams
    new_hams = filter_local_hams(new_hams)

    # Replace pandas NaNs with native Nones
    new_hams = new_hams.where(new_hams.notna(), None)

    # Parse license classes
    new_hams["Class"] = new_hams["Class"].replace(
        to_replace={"T": "Technician", "G": "General", "E": "Amateur Extra"}
    )

    # Minor clean-up
    new_hams["Name"] = new_hams["Name"].str.title()
    new_hams["Email"] = (
        new_hams["Email"].where(new_hams["Email"].notna(), None).str.lower()
    )
    new_hams = new_hams.set_index("Callsign", drop=True)

    # Exclude previously-emailed people
    if previously_emailed_csv is not None:
        emailed = pd.read_csv(previously_emailed_csv)
        emailed = emailed.loc[emailed["Emailed ?"] == True]
        new_hams = new_hams.loc[~new_hams.index.isin(emailed["Callsign"])]

    return new_hams


def combine_with_previously_emailed(
    new_hams: pd.DataFrame, emailed_fname: str
) -> pd.DataFrame:
    """
    Add info about hams that were previously emailed, so we avoid emailing them again.

    Parameters
    ----------
    new_hams : pd.DataFrame
        The data from the new ARRL file.
    emailed_fname : str
        The filename for the file generated by this application, containing info
        about previously-emailed hams.

    Returns
    -------
    pd.DataFrame
        A combined dataframe.
    """

    try:
        previously_emailed = pd.read_csv(emailed_fname)
    except FileNotFoundError:
        previously_emailed = pd.DataFrame(
            columns=["Callsign", "Name", "Class", "Email", "Zip", "Emailed ?"]
        )

    previously_emailed = previously_emailed.set_index("Callsign", drop=True)

    df = pd.concat([new_hams, previously_emailed])
    df["Emailed ?"] = df["Emailed ?"].where(df["Emailed ?"].notna(), None)

    df = df.sort_values("Emailed ?")
    df = df.loc[~df.index.duplicated()]

    return df
